# 다이나믹 프로그래밍(Dynamic Programming)

- 중복되는 부분 문제를 피하면서 계산하는 방식으로 최적화하는 알고리즘.

## 01 다이나믹 프로그래밍의 특징:

1. **중복 부분 문제**: 다이나믹 프로그래밍은 주어진 문제를 작은 하위 문제로 나누고, 각 하위 문제의 해결을 저장해 중복 계산을 피함.

2. **최적 부분 구조**: 큰 문제를 작은 하위 문제로 나눠 해결하고, 이를 결합하여 전체 문제의 최적해를 얻을 수 있음.

3. **메모이제이션**: 중복 계산을 피하기 위해 이전에 계산한 결과를 저장하고 재활용하는 기술을 사용.

4. **시간 복잡도**: 다이나믹 프로그래밍은 중복 계산을 피하므로 일반적으로 효율적인 알고리즘이며, 시간 복잡도는 하위 문제의 개수에 따라 다양하게 변할 수 있음.

## 02 다이나믹 프로그래밍의 구현:

- 일반적으로 재귀 함수나 반복문을 사용하여 중복 계산을 피하고 이전 결과를 저장함.

- 피보나치 수열을 그냥 구현한 코드(시간 복잡도: O(2^n)):

```
def fibonacci(n):
    if 1 == 0:
    	return 0
    elif n == 1:
    	return 1
    fib = fibonacci(n-1) + fibonacci(n-2)
    return fib
```

- 피보나치 수열을 다이나믹 프로그래밍(재귀)으로 구현한 코드(시간 복잡도: O(n)):

```
def fibonacci(n):
    store = [0, 1]
    if n < len(store):
    	return store[n]
    fib = fibonacci(n-1) + fibonacci(n-2)
    store.append(fib)
    return fib
```

- 피보나치 수열을 다이나믹 프로그래밍(반복문)으로 구현한 코드(시간 복잡도: O(n), 공간 복잡도 O(1)):

```
def fibonacci(n):
    store = [0, 1]
    i = 2
    while True:
        if i - 1  == n:
            return store[n]
        store.append(store[i-1] + store[i-2])
        i += 1
```

## 03 다이나믹 프로그래밍의 활용:

- **최적화 문제**: 최단 경로, 최장 공통 부분 수열, 배낭 문제 등 다양한 최적화 문제에 사용.

- **의사 코드 최적화**: 컴퓨터 프로그램의 속도를 향상시키기 위해 중복 계산을 최소화하는 데 사용.

- **경로 탐색**: 그래프 이론에서 최단 경로를 찾거나 특정 조건을 만족하는 경로를 찾을 때 사용.

- **자연어 처리**: 자연어 처리에서 문장 구조 분석, 문장 정렬, 번역 등에 사용.

## 04 다이나믹 프로그래밍의 시간 복잡도:

1. 다이나믹 프로그래밍의 시간 복잡도는 주로 하위 문제의 개수와 각 하위 문제를 해결하는 데 걸리는 시간에 의해 결정됨.

2. 일반적으로 O(N) 또는 O(N^2)와 같이 입력 크기에 따라 다양한 시간 복잡도를 가짐.

3. 메모이제이션을 사용하면 중복 계산을 피하므로 시간 복잡도가 효과적으로 개선됨.

## 05 기타(내가 어려웠던 부분):

- 언제 써야 하는 건지 어려웠다. 다음 조건이 성립할 경우 사용한다고 함.

1. problem이 sub-problem으로 나누어 질 때

2. 각 sub-problem의 solution을 통해 상위 problem의 솔루션을 구할 수 있을 때

3. sub-problem들이 중복되며, 그 문제의 솔루션이 같을 때 → memoizaion
