# 📝 NOTE

```
문제를 해결하면서 알게 된 내용을 정리합니다 :D
```

### 🔑 긴 문자열에 특정 문자열(배열)이 있는지 확인해야 할 때

🔥 [백준 10256 - 돌연변이](https://www.acmicpc.net/problem/10256)

처음에는 아래와 같이 markerSet 자체를 돌면서 이게 dna에 포함되는지를 탐색했다.

```js
for (let i = 0; i < test_count; i++) {
  let count = 0
  const [dna, marker] = case_arr[i]
  const markerSet = getMarkerSet(marker)

  markerSet.forEach((marker) => {
    if (dna.includes(marker)) count++
  })
  console.log(count)
}
```

javaScript의 `includes`의 경우, 첫 번째 문자부터 끝까지 순차적으로 검색하며 지정한 문자열이 포함되어 있는지 확인한다.

```
따라서, for문 안에서 includes를 사용한 경우 시간 복잡도는 O(n * m)
(n: markerSet의 길이, m: dna의 길이)
```

#### ✨ 굳이 dna를 끝까지 돌면서 찾을 필요가 없었다. 그리고 set을 사용하고 있다.

만약 dna의 길이가 6이고, marker의 길이가 4라고 한다면, dna의 2번 인덱스까지만 가도 된다. 왜냐하면 3번 인덱스부터 끝까지라도 해도 길이가 3이다.

```
dna: O O O O O O
         👆 여기까지만 검사해도 된다는 말
```

그리고 markerSet은 `set`이다.

**⭐️ Set**

- 키-값 쌍을 저장하는 데이터 구조로, 특정 키를 사용하여 해당 값에 매우 빠르게 접근할 수 있다. **해시 함수를 사용하여 키를 해시 코드(일반적으로 정수)로 변환**하고, 이 해시 코드를 인덱스로 사용하여 값을 배열에 저장한다.

- 해시 테이블의 핵심적인 장점은 "평균 시간 복잡도"가 `O(1)`이라는 것이다. 이는 입력 크기와 관계없이 거의 일정한 시간 내에 원하는 값을 찾을 수 있다는 의미이다. 따라서 큰 데이터 집합에서도 매우 빠른 검색 속도를 제공한다.

- 반면 배열의 경우, `includes()` 메소드나 `indexOf()` 메소드 등을 사용할 때 전체 배열을 순차적으로 검색해야 하므로 최악의 경우 시간 복잡도가 `O(n)`이 됩니다. 이는 입력 크기가 커질수록 실행 시간이 선형적으로 증가한다는 의미이다.

- 따라서,**주어진 요소가 존재하는지 확인하는 등의 작업에서는 해시 테이블 기반 구조인 Set이 배열보다 일반적으로 더 빠른 성능**을 보인다.

즉, 시간초과를 개선하기 위해 변경한 사항은 다음과 같다.

1. dna를 `dna.length - marker.length + 1`까지 반복하면서 해당 인덱스부터 marker의 길이만큼 자른다.
2. 이 자른 문자열이 markerSet에 `has`하는지 검사한다.

위와 같이 변경하면 시간 복잡도는 다음과 같다.

```
O(m - n + 1)
(m: dna의 길이, n: marker의 길이)
```
